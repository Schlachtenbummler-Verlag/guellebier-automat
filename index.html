<!doctype html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Saxonischer Güllebier-Rezepte-Automatron</title>
<style>
  :root{
    /* Reels skalieren über Viewporthöhe, damit Automat zur Scoreboard-Höhe passt */
    --reel: clamp(72px, min(18vh, 20vw), 160px);
    --machine-w: min(900px, 96vw);         /* etwas größer */
    --board-w: clamp(320px, 42vw, 520px);  /* leicht schmaler rechts */
  }

  html{ scrollbar-gutter: stable both-edges; }
  body{ background:#000; margin:0; padding:0; font-family:sans-serif; color:#fff; text-align:center; }

  /* ===== Seitenlayout: 2 Spalten, mittig & gleiche Höhen ===== */
  .layout{
    display:grid;
    grid-template-columns: minmax(320px, 1fr) minmax(300px, 520px);
    gap:8px;                    /* enger zusammen */
    min-height:100dvh;          /* volle Bildschirmhöhe inkl. iOS-Safe-Units */
    padding:12px;
    place-content:center;       /* Grid im Viewport mittig */
    align-items:stretch;        /* Kinder gleich hoch */
    max-width:1600px;
    margin:0 auto;
  }
  .layout .left,
  .layout .right{
    align-self:stretch;
    display:flex;
    align-items:stretch;        /* Boxen füllen Spaltenhöhe */
    justify-content:center;
  }

  /* ===== Holzrahmen um die Maschine ===== */
  .frame-wood{
    --frame: clamp(12px, 2.6vw, 36px);
    display:flex;               /* wichtig: damit .gba die volle Höhe füllt */
    align-items:stretch;
    justify-content:center;
    margin:0 auto;
    padding:var(--frame);
    border:var(--frame) solid transparent;
    border-image-source:url('assets/img/wood.svg');
    border-image-slice:140; border-image-width:var(--frame); border-image-repeat:round;
    border-radius:16px;
    box-shadow:0 12px 30px rgba(0,0,0,.35);
    position:relative; max-width:98vw; height:100%;
  }
  .frame-wood::before{
    content:""; position:absolute; inset:calc(var(--frame) - 1px);
    border-radius:12px; box-shadow: inset 0 6px 14px rgba(0,0,0,.35), inset 0 -4px 8px rgba(0,0,0,.25);
    pointer-events:none;
  }

  /* ===== Mobile Toggle (nur mobil sichtbar) ===== */
  .mobile-toggle{ display:none; }

  /* Nur im Hochformat stapeln (Landscape bleibt 2-spaltig) */
  @media (max-width: 900px){
    .mobile-toggle{
      position: sticky; top: 0; z-index: 1000;
      display: flex; gap: 8px; justify-content: center;
      padding: 8px; background: rgba(0,0,0,.6); backdrop-filter: blur(6px);
    }
    .btn.small{ padding: 6px 10px; font-size: .95rem; }

    .layout{ grid-template-columns: 1fr; min-height:auto; }

    /* Sichtbarkeit per data-Attribut auf dem .layout-Container */
    .layout[data-view="slot"]  .right{ display: none !important; }
    .layout[data-view="board"] .left { display: none !important; }

    /* Walzen größer auf Mobil – nutze eher Breite als Höhe */
    :root{ --reel: clamp(96px, 34vw, 170px); }

    /* Buttons auf Mobil nicht so wuchtig */
    .btn{ padding: 6px 10px; }
    .seg label{ padding: 5px 8px; }

    /* Rahmen etwas kompakter, damit mehr Platz für Inhalt bleibt */
    .frame-wood{ --frame: clamp(10px, 2.2vw, 24px); }
  }

  /* Landscape mit sehr geringer Höhe: kompakter */
  @media (max-height: 520px){
    :root{ --reel: clamp(80px, 28vw, 150px); }
    .layout{ gap:8px; padding:8px; }
  }

  /* Automat-Box */
  .gba{ color:#fff; background:#222; padding:18px; border-radius:12px; width:var(--machine-w); box-sizing:border-box; margin:0 auto; height:100%; }

  /* Header */
  .gba__header{ display:grid; grid-template-columns:96px 1fr; column-gap:14px; margin-bottom:6px; }
  .gba__header > *{ grid-column:2; text-align:center; }

  /* 2-spaltig: links Hebel, rechts Reels/Lampen/Ergebnis */
  .gba__machine{ display:grid; grid-template-columns:96px 1fr; gap:14px; align-items:center; margin:12px 0; min-height:min(360px, 70vh); perspective:1000px; }

  /* --------- HEBEL --------- */
  .gba__lever-wrap{ height:100%; display:flex; align-items:center; justify-content:center; }
  .lever{ width:72px; height:300px; position:relative; user-select:none; touch-action:none; cursor:grab; filter: drop-shadow(0 6px 14px rgba(0,0,0,.35)); }
  .lever.locked{ cursor:not-allowed; filter: grayscale(.35) opacity(.9); }
  .lever__back{ position:absolute; inset:0; border-radius:10px; background:linear-gradient(180deg,#1a1a1a,#0f0f0f); box-shadow: inset 0 6px 10px rgba(0,0,0,.6), inset 0 -6px 10px rgba(0,0,0,.4); }
  .lever__slot{ position:absolute; left:50%; top:14px; bottom:14px; width:12px; transform:translateX(-50%); background:#080808; border-radius:8px; box-shadow: inset 0 0 10px rgba(0,0,0,.9); }
  .lever__arm{ position:absolute; left:50%; top:22px; width:6px; bottom:22px; transform:translateX(-50%); background:linear-gradient(180deg,#555,#2a2a2a); border-radius:3px; box-shadow: inset 0 0 4px rgba(0,0,0,.6); }
  .lever__knob{ --y: 0px; position:absolute; left:50%; top:0; width:56px; height:56px; transform: translate(-50%, var(--y)); border-radius:50%; background: radial-gradient(circle at 30% 30%, #fff6b8, #f8d24a 45%, #d3a83c 75%, #8a6b1d 100%); box-shadow: 0 10px 18px rgba(0,0,0,.45), inset 0 2px 0 rgba(255,255,255,.35); transition: transform .28s cubic-bezier(.2,.8,.2,1); z-index:2; }
  .lever.pulling .lever__knob{ box-shadow: 0 12px 22px rgba(0,0,0,.5), inset 0 2px 0 rgba(255,255,255,.35); }
  .lever__knob::after{ content:""; position:absolute; inset:0; border-radius:50%; background:linear-gradient(120deg, rgba(255,255,255,.65) 0%, rgba(255,255,255,0) 40%); mix-blend-mode:screen; opacity:.35; pointer-events:none; }
  .lever__ring{ position:absolute; left:50%; width:32px; height:8px; transform:translate(-50%, calc(var(--y) + 52px)); background:linear-gradient(180deg,#777,#333); border-radius:8px; filter:blur(.2px); transition: transform .28s cubic-bezier(.2,.8,.2,1); z-index:1; }

  /* --------- RECHTE SPALTE --------- */
  .gba__right{ display:flex; flex-direction:column; gap:10px; }

  /* Reels + synchroner Shine */
  .gba__reels{ display:grid; grid-template-columns:repeat(4, 1fr); gap:10px; margin-bottom:0; width:100%; box-sizing:border-box; transform: translateZ(0); will-change: transform; position:relative; overflow:hidden; }
  .gba__reels::before{ content:""; position:absolute; top:0; left:-150%; bottom:0; width:150%; background: linear-gradient(120deg, rgba(255,255,255,0) 30%, rgba(255,255,255,.25) 50%, rgba(255,255,255,0) 70%); transform:skewX(-25deg); animation:shine 12s linear infinite; pointer-events:none; z-index:5; }
  .gba__reels.spinning::before{ display:none; }
  @keyframes shine{ from{ left:-150%; } to{ left:150%; } }

  .reel{ background:#111; padding:10px; border-radius:8px; display:flex; align-items:center; justify-content:center; position:relative; overflow:hidden; box-shadow: inset 0 2px 10px rgba(0,0,0,.6), 0 8px 18px rgba(0,0,0,.25); }
  .reel::before, .reel::after{ content:""; position:absolute; left:0; right:0; height:22%; pointer-events:none; z-index:2; }
  .reel::before{ top:0; background:linear-gradient(to bottom, rgba(0,0,0,.6), rgba(0,0,0,0)); }
  .reel::after{ bottom:0; background:linear-gradient(to top, rgba(0,0,0,.6), rgba(0,0,0,0)); }

  .symbol{ position:relative; width:100%; aspect-ratio:1/1; display:flex; align-items:center; justify-content:center; overflow:hidden; will-change: transform, filter; transition: filter .2s ease; }
  .symbol::after{ content:""; position:absolute; inset:-10% -40% auto -40%; height:60%; background:linear-gradient(to bottom, rgba(255,255,255,.18), rgba(255,255,255,0) 70%); transform: rotate(-12deg); pointer-events:none; z-index:1; }
  .symbol img, .symbol svg{ width:100%; height:100%; object-fit:contain; display:block; }

  /* Effekte während des Spins */
  .gba.shake{ animation: shake .35s ease-in-out both; }
  @keyframes shake{ 0%,100%{transform:translateX(0)} 20%{transform:translateX(-2px)} 40%{transform:translateX(2px)} 60%{transform:translateX(-1px)} 80%{transform:translateX(1px)} }
  .reel.spinning .symbol{ filter: blur(3px) saturate(1.1); animation: spin-jitter .12s linear infinite; }
  @keyframes spin-jitter{ 0%{transform:translateY(-3%)} 50%{transform:translateY(3%)} 100%{transform:translateY(-3%)} }
  .reel.spinning::after{ content:""; position:absolute; inset:-30% -10%; background:linear-gradient(90deg, rgba(255,255,255,0) 30%, rgba(255,255,255,.25) 50%, rgba(255,255,255,0) 70%); filter: blur(6px); opacity:.18; transform: rotate(12deg); animation: streak .5s linear infinite; pointer-events:none; }
  @keyframes streak{ from{transform:rotate(12deg) translateX(-8%)} to{transform:rotate(12deg) translateX(8%)} }
  .reel.stop-bounce .symbol{ animation: stop-bounce .32s cubic-bezier(.2,.8,.2,1) 1; filter:none; }
  @keyframes stop-bounce{ 0%{transform:translateY(10%)} 60%{transform:translateY(-4%)} 100%{transform:translateY(0)} }

  /* --------- LAMPEN --------- */
  .gba__action{ display:flex; justify-content:center; margin:8px 0; width:100%; }
  .lamps{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:center; width:100%; }

  .lamp{ pointer-events:none; user-select:none; display:inline-flex; align-items:center; justify-content:center; min-width:160px; height:56px; padding:0 16px; border-radius:32px; background:linear-gradient(180deg,#2f2f2f,#161616); box-shadow: inset 0 4px 10px rgba(0,0,0,.7), inset 0 -4px 8px rgba(0,0,0,.5); position:relative; overflow:hidden; }
  .lamp__label{ font-weight:900; letter-spacing:.08em; text-transform:uppercase; color:#8a8a8a; text-shadow: 0 1px 0 rgba(0,0,0,.6); }
  .lamp__shine{ content:""; position:absolute; inset:0; background: radial-gradient(ellipse at 50% -30%, rgba(255,255,255,.25), rgba(255,255,255,0) 45%); opacity:.35; mix-blend-mode:screen; pointer-events:none; }

  .lamp--red.active{ background: radial-gradient(circle at 50% 20%, #ffd6d6 0%, #ff4d4d 40%, #b11717 70%, #4a0a0a 100%); box-shadow: 0 0 18px 6px rgba(255,80,80,.55), 0 0 36px 16px rgba(255,80,80,.22); animation: lampPulse 1.2s ease-out 1; }
  .lamp--green.active{ background: radial-gradient(circle at 50% 20%, #eaffea 0%, #4cd964 40%, #1db954 70%, #0e3f1d 100%); box-shadow: 0 0 18px 6px rgba(80,255,120,.55), 0 0 36px 16px rgba(80,255,120,.22); animation: lampPulse 1.2s ease-out 1; }
  .lamp--legend.active{ background:#FFD400; box-shadow: 0 0 18px 6px rgba(255,212,0,.65), 0 0 36px 16px rgba(255,212,0,.28); animation: lampPulse 1.2s ease-out 1; }

  .lamp::after{ content:""; position:absolute; inset:-10px; border-radius:inherit; opacity:0; filter: blur(10px); pointer-events:none; }
  .lamp--legend.glow::after{ background: radial-gradient(ellipse at 50% 50%, rgba(255,212,0,.90), rgba(255,212,0,.45) 42%, rgba(255,212,0,0) 70%); animation: afterglow 3.8s ease-out forwards; }
  .lamp--red.glow::after{ background: radial-gradient(ellipse at 50% 50%, rgba(255,110,110,.85), rgba(255,80,80,.35) 40%, rgba(255,80,80,0) 70%); animation: afterglow 3.8s ease-out forwards; }
  .lamp--green.glow::after{ background: radial-gradient(ellipse at 50% 50%, rgba(120,255,160,.85), rgba(80,255,120,.35) 40%, rgba(80,255,120,0) 70%); animation: afterglow 5s ease-out forwards; }

  @keyframes lampPulse{ 0%{box-shadow:0 0 0 0 rgba(255,255,255,0)} 60%{box-shadow:0 0 28px 12px rgba(255,255,255,.65)} 100%{box-shadow:0 0 18px 6px rgba(255,255,255,.4)} }
  @keyframes afterglow{ 0%{opacity:.6;} 100%{opacity:0;} }

  /* Ergebniscontainer */
  .gba__result{ width:100%; box-sizing:border-box; display:flex; flex-direction:column; gap:6px; padding:8px; background:#111; border-radius:8px; min-height:96px; align-items:center; text-align:center; }
  .gba__result.loading{ color:#ccc; font-style:italic; }
  .gba__result .name{ font-weight:700; margin:0; }
  .gba__result .desc{ margin:0; color:#ccc; }
  .badge{ display:inline-block; margin-right:6px; padding:2px 6px; border-radius:8px; font-size:.85rem; background:#FFD700; color:#000; font-weight:bold; }

  #rotateOverlay{ position:fixed; inset:0; display:none; z-index:9999; background:rgba(0,0,0,.9); color:#FFD700; font-size:1.2rem; line-height:1.4; text-align:center; align-items:center; justify-content:center; padding:20px; box-sizing:border-box; }

  /* ===== Scoreboard ===== */
  .scoreboard{
    background:#1a1a1a; border-radius:12px; padding:12px;
    box-shadow:0 10px 24px rgba(0,0,0,.35); text-align:left;
    position:relative; width:var(--board-w); margin:0 auto; height:100%;
    display:flex; flex-direction:column;
  }
  .scoreboard h3{ margin:0; font-size:1.05rem; letter-spacing:.02em; }
  .scoreboard .toolbar{ display:grid; grid-template-columns: 1fr; gap:10px; align-items:center; margin-bottom:8px; }
  .scoreboard .controls{ display:grid; grid-template-columns:auto 1fr auto; gap:8px; align-items:center; }
  .seg{ display:inline-flex; background:#0e0e0e; border:1px solid #333; border-radius:999px; overflow:hidden; }
  .seg input{ display:none; }
  .seg label{ padding:6px 10px; cursor:pointer; user-select:none; font-size:.9rem; color:#ddd; }
  .seg input:checked + label{ background:#2b2b2b; color:#FFD700; }
  .seg input:disabled + label{ opacity:.5; cursor:not-allowed; }

  .scoreboard table{ width:100%; border-collapse:separate; border-spacing:0 6px; table-layout:fixed; }
  .scoreboard thead th{ position:sticky; top:0; background:#1a1a1a; font-weight:700; padding:6px 8px; text-align:left; z-index:1; }
  .scoreboard tbody tr{ background:#111; }
  .scoreboard tbody td{ padding:6px 8px; vertical-align:middle; }
  .scoreboard tbody tr td:first-child{ border-top-left-radius:8px; border-bottom-left-radius:8px; }
  .scoreboard tbody tr td:last-child{ border-top-right-radius:8px; border-bottom-right-radius:8px; }

  /* Spalten enger machen */
  th.coin-hd{ width:56px; }
  th.player-hd{ width: 12ch; } /* genau 12 Zeichen */
  th.thaler-hd{ width: 8ch; }
  th.title-hd{ width: 160px; }

  .inp-name{
    width: 12ch; max-width:12ch; box-sizing:border-box;
    background:#000; color:#fff; border:1px solid #333; border-radius:6px; padding:6px;
  }

  /* Thaler nur Anzeige, kein Input */
  .thaler{
    width:7ch; background:#000; color:#fff; border:1px solid #333; border-radius:6px; padding:6px;
    text-align:right; font-variant-numeric: tabular-nums;
  }

  .title-badge{ display:inline-block; background:#3a2a1a; color:#ffdba3; padding:4px 8px; border-radius:999px; border:1px solid #7c5a2e; font-weight:700; white-space:nowrap; }

  .coin-cell{ width:56px; position:relative; }
  .coin-wrap{ min-height:44px; display:flex; align-items:center; justify-content:center; }
  .coin{ --d:40px; width:var(--d); height:var(--d); border-radius:50%; background: radial-gradient(circle at 30% 30%, #fff6b8, #f8d24a 45%, #d3a83c 75%, #8a6b1d 100%); box-shadow: inset 0 2px 0 rgba(255,255,255,.35), 0 8px 14px rgba(0,0,0,.35); color:#000; font-weight:900; display:flex; align-items:center; justify-content:center; cursor:pointer; user-select:none; transform: translateZ(0); will-change: transform, opacity; opacity:0; pointer-events:none; transition: opacity .2s ease, transform .2s ease; }
  .coin.show{ opacity:1; pointer-events:auto; transform: translateY(0); }
  .coin:active{ transform: scale(.96); }
  .coin__txt{ filter: drop-shadow(0 1px 0 rgba(255,255,255,.35)); }

  .btn{ background:#444; color:#fff; border:none; border-radius:8px; padding:8px 12px; cursor:pointer; }
  .btn:hover{ background:#666; }
  .btn.gold{ background:#6b560f; border:1px solid #c6a339; color:#ffe38a; }
  .btn.gold:hover{ background:#846b14; }
  .btn.danger{ background:#5a1a1a; border:1px solid #a33; }
  .btn.danger:hover{ background:#7a2424; }
  .btn:disabled{ opacity:.6; cursor:not-allowed; }

  .footer-actions{ display:flex; gap:8px; justify-content:space-between; padding-top:6px; border-top:1px solid #2f2f2f; margin-top:8px; flex-wrap:wrap; }
  .hint{ color:#bbb; font-size:.85rem; margin:.25rem 0 .5rem; }
  .round-info{ font-size:.9rem; color:#ccc; }

  /* Bewegungen reduzieren respektieren */
  @media (prefers-reduced-motion: reduce){
    .gba.shake, .reel.spinning .symbol, .reel.spinning::after { animation:none !important; }
    .gba__reels::before{ display:none !important; }
    .lever__knob, .lever__ring{ transition:none !important; }
    .lamp::after, .lamp, .lamp--green.active, .lamp--legend.active, .lamp--red.active{ animation:none !important; }
    .coin{ transition:none !important; }
  }
</style>
</head>
<body>

<!-- MOBIL-Umschalter -->
<nav class="mobile-toggle" aria-label="Ansicht wählen (mobil)">
  <button id="btnViewSlot" class="btn small" aria-pressed="true">🎰 Slot</button>
  <button id="btnViewBoard" class="btn small" aria-pressed="false">📋 Scoreboard</button>
</nav>

<div class="layout" data-view="slot">
  <div class="left">
    <div class="frame-wood">
      <div id="guellebier-automat" class="gba">
        <div class="gba__header">
          <h2>Saxonischer® Rezepte-Automatron 2000</h2>
          <p class="gba__sub">Welche Rüben müssen für das Güllebier-Rezept geerntet werden?</p>
        </div>

        <div class="gba__machine">
          <!-- HEBEL (Start) -->
          <div class="gba__lever-wrap">
            <div id="lever" class="lever locked" role="button" aria-label="Hebel ziehen, um die Walzen zu starten" tabindex="0">
              <div class="lever__back"></div>
              <div class="lever__slot"></div>
              <div class="lever__arm"></div>
              <div class="lever__knob"></div>
              <div class="lever__ring"></div>
            </div>
          </div>

          <!-- RECHTS: Reels + Lampen + Ergebnis -->
          <div class="gba__right">
            <div class="gba__reels" id="reelContainer">
              <div class="reel" data-index="0"><div class="symbol"></div></div>
              <div class="reel" data-index="1"><div class="symbol"></div></div>
              <div class="reel" data-index="2"><div class="symbol"></div></div>
              <div class="reel" data-index="3"><div class="symbol"></div></div>
            </div>

            <!-- Lampen -->
            <div class="gba__action">
              <div class="lamps" aria-hidden="true">
                <div id="lampOrd" class="lamp lamp--red"><span class="lamp__label">Ordinär</span><div class="lamp__shine"></div></div>
                <div id="lampAlt" class="lamp lamp--green"><span class="lamp__label">Alltäglich</span><div class="lamp__shine"></div></div>
                <div id="lampLeg" class="lamp lamp--legend"><span class="lamp__label">Legendär</span><div class="lamp__shine"></div></div>
              </div>
            </div>

            <!-- Ergebnis -->
            <div class="gba__result" id="gbaResult" role="status" aria-live="polite" aria-atomic="true"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <aside class="right">
    <section class="scoreboard" id="scoreboard" aria-label="Spielertabelle">
      <div class="toolbar">
        <h3>Spieler & Runden</h3>
        <div class="controls">
          <button id="btnReset" class="btn">Reset</button>
          <div class="seg" role="radiogroup" aria-label="Runden">
            <input type="radio" name="rounds" id="r1"  value="1"><label for="r1">1</label>
            <input type="radio" name="rounds" id="r3"  value="3" checked><label for="r3">3</label>
            <input type="radio" name="rounds" id="r5"  value="5"><label for="r5">5</label>
            <input type="radio" name="rounds" id="r10" value="10"><label for="r10">10</label>
            <input type="radio" name="rounds" id="rInf" value="inf"><label for="rInf">∞</label>
          </div>
          <button id="btnStart" class="btn gold" disabled>Start</button>
        </div>
      </div>

      <div class="round-info" id="roundInfo">Runde – / –</div>
      <p class="hint">Trage bis zu 5 Spieler ein (mind. 2). Münzen erscheinen nur bei Spielern mit Namen. Klicke die Münze beim Spieler, der die Thaler erhalten soll.</p>

      <table>
        <thead>
          <tr>
            <th class="coin-hd">&nbsp;</th>
            <th class="player-hd">Spieler</th>
            <th class="thaler-hd">Thaler</th>
            <th class="title-hd">Titel</th>
          </tr>
        </thead>
        <tbody id="sbBody"></tbody>
      </table>

      <div class="footer-actions">
        <!-- Schwierigkeitsgrad -->
        <div class="seg" role="radiogroup" aria-label="Schwierigkeit" id="diffGroup">
          <input type="radio" name="difficulty" id="diffNormal" value="normal" checked><label for="diffNormal">Normal</label>
          <input type="radio" name="difficulty" id="diffEasy"   value="leicht"><label for="diffEasy">Leicht</label>
        </div>

        <!-- Sound Toggle -->
        <button id="btnSound" class="btn">🔊 Sound Aus</button>

        <!-- Beenden -->
        <button id="btnEnd" class="btn danger">Beenden</button>
      </div>
    </section>
  </aside>
</div>

<div id="rotateOverlay">Bitte dreh dein Gerät ins Querformat</div>

<!-- Sounds -->
<audio id="sndLever"   src="assets/snd/lever.mp3" preload="auto" loop></audio>
<audio id="sndRattle"  src="assets/snd/dreh.mp3" loop></audio>
<audio id="sndStop"    src="assets/snd/anhalten.mp3" preload="auto"></audio>
<audio id="sndResult"  src="assets/snd/ergebnis.mp3" preload="auto"></audio>
<audio id="sndFanfare" src="assets/snd/fanfare.mp3" preload="auto"></audio>
<audio id="sndKaching" src="assets/snd/kaching.mp3" preload="auto"></audio>
<audio id="sndLvlUp"   src="assets/snd/lvlup.mp3" preload="auto"></audio>
<audio id="sndClick"   src="assets/snd/click.mp3" preload="auto"></audio>

<script>
function log(msg){ try{ console.log('[Automat]', msg); }catch(e){} }

function handleBack(){
  try { window.close(); } catch(e) {}
  if (document.visibilityState === 'visible') {
    if (history.length > 1) { history.back(); return; }
    if (document.referrer)  { location.href = document.referrer; return; }
  }
  location.href = 'https://schlachtenbummler-verlag.jimdosite.com/neu/';
}

function checkOrientation(){
  const ov = document.getElementById('rotateOverlay');
  if (!ov) return;
  ov.style.display = (window.innerHeight > window.innerWidth) ? 'flex' : 'none';
}

/* ====== SLOT-MASCHINE ====== */
document.addEventListener('DOMContentLoaded',()=>{
  checkOrientation();
  window.addEventListener('resize', checkOrientation);
  window.addEventListener('orientationchange', checkOrientation);

  const reels = Array.from(document.querySelectorAll('.reel'));
  const reelContainer = document.getElementById('reelContainer');
  const out   = document.getElementById('gbaResult');
  const machine = document.querySelector('.gba');

  // Lampen
  const lampOrd = document.getElementById('lampOrd');
  const lampAlt = document.getElementById('lampAlt');
  const lampLeg = document.getElementById('lampLeg');
  const lampTimers = new WeakMap();

  // Sounds
  const sndLever  = document.getElementById('sndLever') || document.getElementById('sndRattle');
  const sndRattle = document.getElementById('sndRattle');
  const sndStop   = document.getElementById('sndStop');
  const sndResult = document.getElementById('sndResult');
  const sndFanfare= document.getElementById('sndFanfare');
  const sndKaching= document.getElementById('sndKaching');
  const sndLvlUp  = document.getElementById('sndLvlUp');

  const COLORS = ['rot','blau','gruen','gelb'];
  const IMG = { rot:'assets/img/rot.png', blau:'assets/img/blau.png', gruen:'assets/img/gruen.png', gelb:'assets/img/gelb.png' };
  const SVG = {
    rot:`<svg viewBox='0 0 64 64' xmlns='http://www.w3.org/2000/svg'><path fill='#2b9e45' d='M42 10c6 1 10 6 10 12-6-2-11-6-10-12zM37 9c-2 5-8 10-15 10 3-7 9-11 15-10z'/><path fill='#d94a4a' d='M31 18c10 0 19 8 19 18S43 54 31 54 12 45 12 36s9-18 19-18z'/></svg>`,
    blau:`<svg viewBox='0 0 64 64' xmlns='http://www.w3.org/2000/svg'><path fill='#2c9aa7' d='M42 10c6 1 10 6 10 12-6-2-11-6-10-12zM37 9c-2 5-8 10-15 10 3-7 9-11 15-10z'/><path fill='#3a7bd5' d='M31 18c10 0 19 8 19 18S43 54 31 54 12 45 12 36s9-18 19-18z'/></svg>`,
    gruen:`<svg viewBox='0 0 64 64' xmlns='http://www.w3.org/2000/svg'><path fill='#1f8a4c' d='M42 10c6 1 10 6 10 12-6-2-11-6-10-12zM37 9c-2 5-8 10-15 10 3-7 9-11 15-10z'/><path fill='#2ecc71' d='M31 18c10 0 19 8 19 18S43 54 31 54 12 45 12 36s9-18 19-18z'/></svg>`,
    gelb:`<svg viewBox='0 0 64 64' xmlns='http://www.w3.org/2000/svg'><path fill='#79b92f' d='M42 10c6 1 10 6 10 12-6-2-11-6-10-12zM37 9c-2 5-8 10-15 10 3-7 9-11 15-10z'/><path fill='#f5d142' d='M31 18c10 0 19 8 19 18S43 54 31 54 12 45 12 36s9-18 19-18z'/></svg>`
  };

  const RECIPES = {
    'rot,rot,rot,rot':   {name:'Dösselheimer Güllebier',        pts:15, desc:'Die braune Seele Saxoniens.'},
    'blau,blau,blau,blau': {name:'Leberknebel - Export',        pts:15, desc:'Seitenstechen auch ohne Meuchelmörder.'},
    'gruen,gruen,gruen,gruen': {name:'Braune Soße',            pts:14, desc:'Zähflüssig, herzhaft, löst Sorgen und Rost.'},
    'gelb,gelb,gelb,gelb': {name:'Flotter Otto - Extra Hell',   pts:14, desc:'Fließt es erst heraus, bleibst du lieber gleich zuhaus!'},

    'rot,rot,rot,blau':  {name:'Klemritzer Nierenquetscher',    pts:13, desc:'Massiert die Organe von innen nach außen.'},
    'rot,rot,rot,gruen': {name:'Rülpsheimer Starkbier',         pts:13, desc:'Schenkt Bass im Bauch.'},
    'rot,rot,rot,gelb':  {name:'Lord Villains Glanzparade',     pts:13, desc:'Edel und unbestechlich herb.'},
    'blau,blau,blau,rot':  {name:'Donnerburger Steißtritt',     pts:13, desc:'Treffsicherer Geschmack.'},
    'blau,blau,blau,gruen':{name:'Hassnitzer Kellerbräu',       pts:13, desc:'Aus dem ganz dunklen Fass.'},
    'blau,blau,blau,gelb': {name:'Stinkhornsuppe - Spezial',    pts:13, desc:'Duftet nach Abenteuer, Freiheit und alten Socken.'},
    'gruen,gruen,gruen,rot': {name:'Plärrener Humpentrunk',     pts:13, desc:'Groß im Glas, laut im Kopf.'},
    'gruen,gruen,gruen,blau':{name:'Hassburger Urstoff Brühe',  pts:13, desc:'So bekömmlich wie eine kleine Pilzvergiftung.'},
    'gruen,gruen,gruen,gelb':{name:'Dreschmarer Magenhieb',     pts:12, desc:'Direkt, ehrlich, unvergesslich.'},
    'gelb,gelb,gelb,rot':  {name:'Knurrwitzer Abtritt',         pts:12, desc:'So männlich wie konservative Ein - Artikler.'},
    'gelb,gelb,gelb,blau': {name:'Ynnors Schnarchtrunk',        pts:12, desc:'Wirkt sofort.'},
    'gelb,gelb,gelb,gruen':{name:'Schwitzwasser Abblende',      pts:12, desc:'Leicht bekömmliches Dünnbier.'},

    'rot,rot,blau,blau':   {name:'Beißburger Rübenhamsterwurf', pts:11, desc:'Zwei Paare, ein Ziel.'},
    'rot,rot,gruen,gruen': {name:'Ningelner Nostalgiker - Urtyp',pts:11, desc:'Schmeckt so gut wie früher, nur besser.'},
    'rot,rot,gelb,gelb':   {name:'Stockheimer Knollentrunk',    pts:10, desc:'Dick im Glas, jetzt mit noch mehr Fruchtfleisch.'},
    'blau,blau,gruen,gruen':{name:'Plärrener Feldschorle - Spezial', pts:10, desc:'Damit sie auch Morgen noch lauthals schreien können.'},
    'blau,blau,gelb,gelb': {name:'Grollstädter Rübensprudel - Deluxe', pts:9, desc:'Gebraut mit Liebe.'},
    'gruen,gruen,gelb,gelb':{name:'Grimmiger Krauttrunk - Extra Herb', pts:9, desc:'Kratzig im Abgang.'},

    'rot,rot,blau,gruen': {name:'Kellerleichen - Party - Mix',  pts:8, desc:'Für Nächte an die man sich lieber nicht erinnert.'},
    'rot,rot,blau,gelb':  {name:'Broilinger Doppelacker Sud',   pts:7, desc:'Das beste aus zwei Welten.'},
    'rot,rot,gruen,gelb': {name:'Feierabend Erntetrunk',        pts:7, desc:'Erfrischend wie eine 16 Stundenschicht bei Schnell & Billig.'},

    'blau,blau,rot,gruen': {name:'Zwicker Feldweg - Knöchelknacks', pts:6, desc:'Holprig und bitter.'},
    'blau,blau,rot,gelb':  {name:'Ackerbowle',                  pts:6, desc:'Erdig-Herb'},
    'blau,blau,gruen,gelb':{name:'Lumpa Umpas goldene Brause - Edel', pts:6, desc:'Kurz aber kräftig.'},

    'gruen,gruen,rot,blau': {name:'Freudloser Hopfenrübling - Hell', pts:5, desc:'Der Spaß aus dem Glas.'},
    'gruen,gruen,rot,gelb': {name:'Ackerschorle - Export',      pts:5, desc:'Das Erfrischungsgetränk für jede Arbeit.'},
    'gruen,gruen,blau,gelb':{name:'Winkelstädter Gärtnerpils',  pts:5, desc:'Gereift im Biercubus.'},

    'gelb,gelb,rot,blau':  {name:'Lästerhainer Jodelsprudel',   pts:4, desc:'Nach zwei Schlucken singst du.'},
    'gelb,gelb,rot,gruen': {name:'Donnerburger Rübenschädel - Spezial', pts:4, desc:'Gebraut mit Blitz und Donner.'},
    'gelb,gelb,blau,gruen':{name:'Karnickelfangschlag',         pts:4, desc:'Erst pelzig auf der Zunge, dann schnell im Abgang.'},

    'rot,blau,gruen,gelb': {name:'Querbeet - Klassik',          pts:2, desc:'Von allem ein bisschen.'}
  };  

  const RECIPES_INDEX={};
  Object.keys(RECIPES).forEach(k=>{ RECIPES_INDEX[k.split(',').sort().join(',')] = RECIPES[k]; });
  const normalize = combo => combo.slice().sort().join(',');
  const ALL_KEYS = Object.keys(RECIPES_INDEX);
  let usedKeys = new Set(); // für Leicht

  // Difficulty
  const diffInputs = Array.from(document.querySelectorAll('input[name="difficulty"]'));
  const getDifficulty = () => (diffInputs.find(i=>i.checked)?.value || 'normal');

  // Runden
  const roundInputs = Array.from(document.querySelectorAll('input[name="rounds"]'));
  const getSelectedRounds = ()=>{ const v = (document.querySelector('input[name="rounds"]:checked')||{}).value; return v==='inf' ? Infinity : Math.max(1, parseInt(v||'3',10)); };
  function setRoundsDisabled(dis){ roundInputs.forEach(i=> i.disabled = dis); }

  // Ergebnis-Auswertung (mit Punkte-Modifikator für Leicht)
  function evaluate(result, awardedPtsOverride=null){
    const key = normalize(result);
    const recipe = RECIPES_INDEX[key] || {name:'Krautwasser',pts:0,desc:'Schmeckt nach nix.'};

    // Punkte ggf. reduzieren (Leicht)
    const EASY_MOD = -3;
    const awardedPts = (awardedPtsOverride!=null)
      ? awardedPtsOverride
      : (getDifficulty()==='leicht' ? Math.max(1, recipe.pts + EASY_MOD) : recipe.pts);

    out.innerHTML = `
      <div class="name">${recipe.name}</div>
      <div class="desc">${recipe.desc || ''}</div>
      <div class="reward"><span class="badge">+${awardedPts} Thaler</span> für den Rübensammler, welcher den Auftrag als erstes erfüllt!</div>`;

    [lampOrd, lampAlt, lampLeg].forEach(l => {
      const prev = lampTimers.get(l); if (prev) { clearTimeout(prev); lampTimers.delete(l); }
      l.classList.remove('active','glow');
    });

    if (recipe.pts >= 1 && recipe.pts <= 7)      activateLamp(lampOrd, false);
    else if (recipe.pts >= 8 && recipe.pts <= 12) activateLamp(lampAlt, false);
    else if (recipe.pts >= 13)                    activateLamp(lampLeg, true);

    try { sndResult.currentTime = 0; sndResult.play(); } catch(e){}

    document.dispatchEvent(new CustomEvent('gba:result', { detail: { result: result.slice(), recipe, awardedPts } }));
  }

  function activateLamp(el, isLegend){
    if(!el) return;
    const prev = lampTimers.get(el); if (prev) { clearTimeout(prev); lampTimers.delete(el); }
    el.classList.remove('glow','active'); void el.offsetWidth; el.classList.add('active','glow');
    if (isLegend) { try { sndFanfare.pause(); sndFanfare.currentTime = 0; sndFanfare.play(); } catch(e){} }
    let duration = 4200; if (el.classList.contains('lamp--green')) duration = 5000; if (el.classList.contains('lamp--legend')) duration = 4200;
    const t = setTimeout(()=>{ el.classList.remove('active','glow'); lampTimers.delete(el); }, duration); lampTimers.set(el, t);
  }

  function setSymbol(reelEl,color){
    const sym = reelEl.querySelector('.symbol');
    sym.className = 'symbol ' + color;
    const img = new Image();
    img.decoding='async';
    img.alt = color + 'e Rübe';
    img.onload = ()=>{ sym.innerHTML=''; sym.appendChild(img); };
    img.onerror = ()=>{ sym.innerHTML = SVG[color]; };
    img.src = IMG[color];
  }
  const randomColor = () => COLORS[Math.floor(Math.random()*COLORS.length)];

  // Startanzeige
  reels.forEach(reel => setSymbol(reel, randomColor()));

  /* ---------- Hebel-Logik ---------- */
  const lever = document.getElementById('lever');
  const knob  = lever.querySelector('.lever__knob');
  const ring  = lever.querySelector('.lever__ring');

  let isDragging = false; let isSpinning = false; let startY = 0, startKnob = 0; let minY = 0, maxY = 0, knobH = 56, pad = 14;
  function measure(){ const rect = lever.getBoundingClientRect(); maxY = rect.height - knobH - pad; minY = 0; }
  measure(); window.addEventListener('resize', measure);

  function setKnobY(y, withTransition=true){
    const clamped = Math.max(minY, Math.min(maxY, y));
    if(!withTransition){ knob.style.transition='none'; ring.style.transition='none'; }
    knob.style.setProperty('--y', clamped + 'px');
    ring.style.transform = `translate(-50%, ${clamped + 52}px)`;
    if(!withTransition){ void knob.offsetHeight; }
    return clamped;
  }
  function enableKnobTransition(){
    knob.style.transition = 'transform .28s cubic-bezier(.2,.8,.2,1)';
    ring.style.transition = 'transform .28s cubic-bezier(.2,.8,.2,1)';
  }

  function pullStart(e){
    if(isSpinning || lever.classList.contains('locked')) return;
    isDragging = true; lever.classList.add('pulling');
    const pY = ('touches' in e) ? e.touches[0].clientY : e.clientY;
    startY = pY;
    const current = parseFloat(getComputedStyle(knob).getPropertyValue('--y')) || 0;
    startKnob = current;
    setKnobY(current, false);
    try{ sndLever.currentTime=0; sndLever.play(); }catch(_){}
    if(lever.setPointerCapture && e.pointerId != null){ lever.setPointerCapture(e.pointerId); }
    e.preventDefault();
  }
  function pullMove(e){
    if(!isDragging) return;
    const pY = ('touches' in e) ? e.touches[0].clientY : e.clientY;
    const dy = pY - startY;
    setKnobY(startKnob + dy, false);
    e.preventDefault();
  }
  function pullEnd(){
    if(!isDragging) return;
    isDragging = false; lever.classList.remove('pulling'); enableKnobTransition();
    try{ sndLever.pause(); }catch(_){}
    const current = parseFloat(getComputedStyle(knob).getPropertyValue('--y')) || 0;
    const ratio = current / (maxY || 1);
    setKnobY(minY, true);
    if(ratio >= 0.8 && !isSpinning){ spin(); }
  }

  lever.addEventListener('pointerdown', pullStart);
  lever.addEventListener('pointermove', pullMove);
  lever.addEventListener('pointerup', pullEnd);
  lever.addEventListener('pointercancel', pullEnd);
  lever.addEventListener('touchstart', pullStart, {passive:false});
  lever.addEventListener('touchmove',  pullMove,  {passive:false});
  lever.addEventListener('touchend',   pullEnd);
  lever.addEventListener('mousedown',  pullStart);
  window.addEventListener('mousemove', pullMove);
  window.addEventListener('mouseup',   pullEnd);

  // Tastatur-Fallback
  lever.addEventListener('keydown', (e)=>{
    if(isSpinning || e.repeat || lever.classList.contains('locked')) return;
    if(e.key === ' ' || e.key === 'Enter'){
      e.preventDefault(); setKnobY(maxY, true); try{ sndLever.currentTime=0; sndLever.play(); }catch(_){ }
      setTimeout(()=>{ setKnobY(minY, true); try{ sndLever.pause(); }catch(_){}; spin(); }, 180);
    }
  });

  /* ======= SCOREBOARD ======= */
  const sbBody = document.getElementById('sbBody');
  const btnStart = document.getElementById('btnStart');
  const btnReset = document.getElementById('btnReset');
  const btnEnd   = document.getElementById('btnEnd');
  const roundInfo= document.getElementById('roundInfo');

  const titleSteps = [0, 50, 150, 300, 600];
  const titles = [ 'Rübenhamster', 'Rübenknecht', 'Rübenzähler', 'Rübenbaron', 'Rübenmagnat' ];
  const titleIndexFor = (thaler)=>{ let idx = 0; for(let i=0;i<titleSteps.length;i++){ if(thaler >= titleSteps[i]) idx=i; } return idx; }
  const titleFor = (thaler)=> titles[titleIndexFor(thaler)];

  /* Startzustand: A/B gesetzt, andere leer */
  let players = new Array(5).fill(null).map((_,i)=>({
    id: 'p'+(i+1),
    name: (i===0 ? 'Spieler A' : i===1 ? 'Spieler B' : ''),
    thaler:0
  }));
  let gameActive = false; let totalRounds = 0; let currentRound = 0; let awaitingAssign = false; let pendingPts = 0;

  function renderRows(){
    sbBody.innerHTML = '';
    players.forEach((p,idx)=>{
      const ph = (idx===0 ? 'Spieler A' : idx===1 ? 'Spieler B' : '');
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td class="coin-cell"><div class="coin-wrap"><div class="coin" data-id="${p.id}" aria-label="Thaler zuweisen"><span class="coin__txt">+0</span></div></div></td>
        <td>
          <input type="text" inputmode="text" maxlength="12"
                 value="${escapeHtml(p.name)}"
                 placeholder="${ph}"
                 data-id="${p.id}" class="inp-name">
        </td>
        <td><div class="thaler" id="thaler-${p.id}" aria-label="Thalerstand">${p.thaler}</div></td>
        <td><span class="title-badge" id="title-${p.id}">${titleFor(p.thaler)}</span></td>`;
      sbBody.appendChild(tr);
    });
    updateStartEnabled();
    setNameInputsDisabled(gameActive);

    /* --- WICHTIG: Beim Reinklicken (focus) IMMER INHALT LEEREN ---
       -> Eingetragene Namen bleiben, bis man reinklickt.
       -> Gilt für alle 5 Zeilen. */
    sbBody.querySelectorAll('.inp-name').forEach(inp=>{
      inp.addEventListener('focus',()=>{
        const id = inp.getAttribute('data-id');
        const p = players.find(x=>x.id===id);
        inp.value = '';
        if(p) p.name = '';
        updateStartEnabled();
      }, { once:false });
    });
  }

  function updateStartEnabled(){
    const filled = players.filter(p=>p.name.trim().length>0).length;
    btnStart.disabled = gameActive || !(filled >= 2);
    setRoundsDisabled(gameActive);
    diffInputs.forEach(i=> i.disabled = gameActive);
  }

  function updateTitles(){
    players.forEach(p=>{
      const el = document.getElementById('title-'+p.id);
      if(el) el.textContent = titleFor(p.thaler);
      const tv = document.getElementById('thaler-'+p.id);
      if(tv) tv.textContent = p.thaler;
    });
  }

  function updateRoundInfo(){
    const tot = (totalRounds===Infinity? '∞' : totalRounds);
    const cur = (totalRounds===Infinity? currentRound : Math.min(currentRound,totalRounds));
    roundInfo.textContent = `Runde ${cur} / ${tot}`;
  }

  function setNameInputsDisabled(dis){
    sbBody.querySelectorAll('.inp-name').forEach(inp => { inp.disabled = dis; if(dis) inp.classList.add('disabled'); else inp.classList.remove('disabled'); });
  }

  function showCoins(value){
    pendingPts = value;
    awaitingAssign = value>0;
    let anyShown = false;
    players.forEach((p,idx)=>{
      const coin = sbBody.querySelectorAll('.coin')[idx];
      const isActive = p.name.trim().length>0;
      if(coin){
        const txt = coin.querySelector('.coin__txt'); if(txt) txt.textContent = '+'+value;
        coin.classList.toggle('show', value>0 && isActive);
        if(value>0 && isActive) anyShown = true;
      }
    });
    if(value===0 || !anyShown){
      endRound();
    } else {
      // Mobil: bei Ergebnis automatisch das Scoreboard zeigen
      setView('board');
    }
  }
  function hideCoins(){ document.querySelectorAll('.coin').forEach(c=> c.classList.remove('show')); awaitingAssign = false; pendingPts = 0; }

  // Eingaben normalisieren (keine doppelten Spaces, Wortanfänge groß)
  sbBody.addEventListener('input', (e)=>{
    const t = e.target;
    const id = t.getAttribute('data-id');
    const p = players.find(x=>x.id===id);
    if(!p) return;

    if (t.classList.contains('inp-name')) {
      let val = t.value.replace(/\s+/g, ' ').trimStart();
      val = val.replace(/\b\p{L}/gu, c => c.toUpperCase());
      t.value = val;
      p.name = val;
      updateStartEnabled();
    }
  });

  // Coin click -> assign points (+ LevelUp & Sound)
  sbBody.addEventListener('click', (e)=>{
    const coin = e.target.closest('.coin');
    if(!coin || !awaitingAssign) return;
    const id = coin.getAttribute('data-id'); const p = players.find(x=>x.id===id); if(!p) return;

    const oldIdx = titleIndexFor(p.thaler);
    p.thaler += pendingPts;
    try{ sndKaching.currentTime=0; sndKaching.play(); }catch(_){}
    const tEl = document.getElementById(`thaler-${id}`); if(tEl) tEl.textContent = p.thaler;
    updateTitles();
    const newIdx = titleIndexFor(p.thaler);
    if(newIdx > oldIdx){ try{ sndLvlUp.currentTime=0; sndLvlUp.play(); }catch(_){} }
    hideCoins(); endRound();
  });

  btnStart.addEventListener('click', ()=>{
    if(gameActive) return;
    totalRounds = getSelectedRounds(); currentRound = 0; gameActive = true; updateRoundInfo();
    lever.classList.remove('locked');
    setNameInputsDisabled(true);
    updateStartEnabled();
    if(getDifficulty()==='leicht'){ usedKeys = new Set(); }
    hideCoins();

    // Mobil: bei Start automatisch Slot anzeigen
    setView('slot');
  });

  function performReset(){
    stopSpinNow(true);
    players = new Array(5).fill(null).map((_,i)=>({
      id: 'p'+(i+1),
      name: (i===0 ? 'Spieler A' : i===1 ? 'Spieler B' : ''),
      thaler:0
    }));
    gameActive = false; totalRounds = 0; currentRound = 0; awaitingAssign = false; pendingPts = 0;
    usedKeys = new Set();
    renderRows(); updateTitles(); updateRoundInfo();
    lever.classList.add('locked');
    updateStartEnabled();
    out.innerHTML = '';
  }
  function softResetKeepNames(){
  // nur Zustand & Punkte zurücksetzen – Namen bleiben!
  stopSpinNow(true);
  gameActive = false;
  totalRounds = 0;
  currentRound = 0;
  awaitingAssign = false;
  pendingPts = 0;
  usedKeys = new Set();

  // Punkte/Titel auf 0 zurück, Namen unverändert
  players = players.map(p => ({ ...p, thaler: 0 }));

  renderRows();        // baut Inputs neu (mit Focus-Clear)
  updateTitles();      // zeigt 0 Punkte / Starttitel
  updateRoundInfo();   // "Runde – / –"
  lever.classList.add('locked');
  updateStartEnabled();
  out.innerHTML = '';
}

  btnReset.addEventListener('click', performReset);

  btnEnd.addEventListener('click', ()=>{
    const sure = confirm('Seite verlassen?\nJa = Zurück/Exit, Nein = weiterspielen');
    if (sure) { handleBack(); }
  });

  // --- Sound Toggle ---
  const btnSound = document.getElementById('btnSound');
  let soundOn = true;
  btnSound.addEventListener('click', ()=>{
    soundOn = !soundOn;
    document.querySelectorAll('audio').forEach(a => a.muted = !soundOn);
    btnSound.textContent = soundOn ? "🔊 Sound Aus" : "🔈 Sound An";
  });

  // --- Mobile Ansicht-Umschalter (Slot / Board) ---
  const layoutEl = document.querySelector('.layout');
  const btnViewSlot  = document.getElementById('btnViewSlot');
  const btnViewBoard = document.getElementById('btnViewBoard');

  function setView(view){
    if(!layoutEl) return;
    layoutEl.setAttribute('data-view', view);
    if(btnViewSlot && btnViewBoard){
      btnViewSlot.setAttribute('aria-pressed', String(view==='slot'));
      btnViewBoard.setAttribute('aria-pressed', String(view==='board'));
    }
  }
  // Standard: Slot-Ansicht
  setView('slot');

  btnViewSlot?.addEventListener('click',  ()=> setView('slot'));
  btnViewBoard?.addEventListener('click', ()=> setView('board'));

  // Auf Slot-Result warten
  document.addEventListener('gba:result', (ev)=>{
    if(!gameActive) return;
    const pts = (ev.detail && (ev.detail.awardedPts!=null)) ? ev.detail.awardedPts :
                (ev.detail && ev.detail.recipe && ev.detail.recipe.pts) ? ev.detail.recipe.pts : 0;
    showCoins(pts);
  });

  function endRound(){
    currentRound += 1; updateRoundInfo();
    if (currentRound < totalRounds || totalRounds===Infinity){
      lever.classList.remove('locked');
    } else {
      finishGame();
    }
  }

  function finishGame(){
    gameActive = false; lever.classList.add('locked'); hideCoins();
    const max = Math.max(0, ...players.map(p=>p.thaler));
    Array.from(sbBody.querySelectorAll('tr')).forEach((tr,i)=>{
      const p = players[i];
      tr.style.outline = (p && p.thaler===max && max>0) ? '2px solid #FFD700' : 'none';
      tr.style.boxShadow = (p && p.thaler===max && max>0) ? '0 0 14px rgba(255,215,0,.25) inset' : 'none';
    });
    const winners = players.filter(p=>p.thaler===max && p.name.trim()).map(p=>p.name);
    alert('Spielende! Gewinner: ' + (winners.length ? winners.join(', ') : '—'));
   softResetKeepNames();
  }

  /* ====== Dreh-Logik + Schwierigkeits-Handling ====== */
  let spinIntervals = [];
  let spinTimeouts  = [];
  function clearSpinTimers(){
    spinIntervals.forEach(i=> clearInterval(i)); spinIntervals = [];
    spinTimeouts.forEach(t=> clearTimeout(t));  spinTimeouts  = [];
  }
  function stopSpinNow(silence=false){
    clearSpinTimers();
    isSpinning = false;
    reelContainer.classList.remove('spinning');
    reels.forEach(reel=> reel.classList.remove('spinning','stop-bounce'));
    if(!silence){ try{ sndRattle.pause(); }catch(_){} }
  }

  function pickLeichtTarget(){
    if(usedKeys.size >= ALL_KEYS.length){ usedKeys.clear(); }
    const remaining = ALL_KEYS.filter(k=> !usedKeys.has(k));
    const key = remaining[Math.floor(Math.random()*remaining.length)];
    usedKeys.add(key);
    const arr = key.split(',');
    for(let i=arr.length-1;i>0;i--){ const j = Math.floor(Math.random()*(i+1)); [arr[i],arr[j]] = [arr[j],arr[i]]; }
    return arr;
  }

  function spin(){
    if (lever.classList.contains('locked')) return;
    isSpinning = true; lever.classList.add('locked');

    out.setAttribute('aria-busy', 'true');
    [lampOrd, lampAlt, lampLeg].forEach(l => {
      const prev = lampTimers.get(l); if (prev) { clearTimeout(prev); lampTimers.delete(l); }
      l.classList.remove('active','glow');
    });

    out.classList.add("loading"); out.innerHTML = `<div>…suche Rezept für den Ernteauftrag…</div>`;
    machine?.classList.add('shake'); setTimeout(()=> machine?.classList.remove('shake'), 380);
    reelContainer.classList.add('spinning');

    try{ sndRattle.currentTime=0; sndRattle.play(); }catch(_){}

    const difficulty = getDifficulty();
    const targetCombo = (difficulty==='leicht') ? pickLeichtTarget() : null;

    const finals = []; const baseStops = [1100, 1750, 2400, 3050];
    reels.forEach((reel,i)=>{
      reel.classList.add('spinning'); const speed = 95;
      const intId = setInterval(()=> setSymbol(reel, randomColor()), speed);
      spinIntervals.push(intId);
      const stopAfter = baseStops[i] + Math.floor(Math.random()*260);
      const toId = setTimeout(()=>{
        clearInterval(intId);
        let c = targetCombo ? targetCombo[i] : randomColor();
        setSymbol(reel, c); finals[i] = c;
        try{ sndStop.currentTime=0; sndStop.play(); }catch(_){}
        reel.classList.remove('spinning'); reel.classList.add('stop-bounce'); reel.addEventListener('animationend', ()=> reel.classList.remove('stop-bounce'), {once:true});
        if(i === reels.length-1){
          try{ sndRattle.pause(); }catch(_){}
          out.classList.remove("loading"); out.removeAttribute('aria-busy'); reelContainer.classList.remove('spinning');
          evaluate(finals);
          isSpinning = false;
        }
      }, stopAfter);
      spinTimeouts.push(toId);
    });
  }

  // Initial rows
  renderRows(); updateTitles(); updateRoundInfo(); updateStartEnabled();
}); // DOMContentLoaded

/* --- Klick-Sound für Buttons und Radio/Checkbox-Inputs --- */
const sndClick = document.getElementById('sndClick');
document.addEventListener('click', (e)=>{
  if (!sndClick) return;
  if (
    e.target.closest('button') ||
    e.target.matches('input[type="radio"], input[type="checkbox"]')
  ) {
    try { sndClick.currentTime = 0; sndClick.play(); } catch(_) {}
  }
});

// Utils
function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, c => ({
    "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"
  }[c]));
}
</script>
</body>
</html>
